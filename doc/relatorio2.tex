\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}

\usepackage{tikz}

\usepackage{minted}
\newminted{cpp}{gobble=4, linenos, mathescape}
\newcommand{\xor}{\otimes}

\newcommand{\colvec}[1]{
    \tikz[baseline=-3pt]{
        \node (center) at (0, 0) {$#1$};
        \draw (center) -- (0, 1) (0, 1.2);
        \draw (center) -- (0, -1) (0, -1.2);
    }
    % O -3pt, o 1.2 e o -1.2 são admitidamente gambiarrizados.
}

\title{
    INE5451 - Tópicos Especiais em Algoritmos I \\
    Introdução à Criptoanálise \\
    Relatorio II
}
\author{
    Lucas Zarbato - 11100890\\
    Tiago Royer - 12100776
}

\date{3 de Julho de 2015}

\begin{document}

\maketitle

\section{Introdução}

O trabalho a ser entregue consistia de seis questões
relacionadas ao conteúdo aprendido em aula.
As três primeiras eram obrigatórias
e envolviam a implementação do ataque integral ao AES,
implementação do RSA
e o desenvolvimento de um ataque linear a uma SPN.
As últimas três eram eletivas e precisavam ser escolhidas
dentre um leque de 6 opções.
Escolhemos fazer as últimas três questões, relacionadas ao log discreto.

Novamente, fizemos todos os programas em C++.
Nosso código está disponível em \texttt{https://github.com/royertiago/INE5451}.

\section{Questão 2 --- Ataque quadrado ao AES}

Este problema pedia que implementássemos o ataque quadrado ao AES.
Como o algoritmo foi estudado em detalhes na aula,
discutiremos aqui apenas questões de implementação.

\subsection{Estruturas de dados}

Definimos duas estruturas de dados para este algoritmo.
A primeira,
a classe \verb"polynomial"
(definida no arquivo \verb"aes/polynomial.h"),
encapsula toda a parafernália relacionada
à manipulação de elementos no corpo de Galois usado pelo AES.
A multiplicação de dois elementos é tabelada no início do programa,
reduzindo o cálculo do produto de dois elementos do corpo
a um acesso a vetor.

A segunda clase,
\verb"matrix" (definida em \verb"aes/matrix.h"),
representa as chaves, subchaves, dados a serem cifrados
e algumas operações lineares.

\subsection{Extração e reconstrução de subchaves}

Visando simplificar o algoritmo,
separamos em funções as operações do AES.
A extração de subchaves a partir de uma chave
e reconstituição da chahve original a partir de uma subchave
ficaram no arquivo \verb"aes/subkeys.h".

\begin{cppcode}
    namespace aes {
        std::vector<matrix> subkeys( matrix key, int rounds );
        matrix superkey( const matrix & subkey, int round );
    }
\end{cppcode}

A função \verb"subkeys" constrói um vetor de \verb"rounds+1" subchaves
a partir da chave dada;
O elemento de índice $0$ do vetor de subchaves é a própria chave inicial,
e o elemento no índice $i$ é a subchave usada pela operação \emph{AddRoundKey}
na rodada $i$ do AES.
(Adicionamos o parâmetro \verb"rounds" para facilitar a alternância
entre o AES com 4 rodadas e o AES com 10.)
A função \verb"superkey" reconstrói a chave original,
assumindo que a chave dada veio da rodada \verb"round".

Embora a norma do AES defina a geração de subchaves em termos de
uma lista de vetores-coluna%
\footnote{
    Usamos o termo ``vetor-coluna'' no sentido que ele tem na álgebra linear.
    Adicionamos o sufixo ``-coluna'' para diferenciá-lo
    do conceito de ``vetor'' utilizado nas linguagens de programação
    (o ``vetor'' de ``vetor de subchaves'').
},
usando apenas as colunas $W(4i)$, $W(4i+1)$, $W(4i+2)$ e $W(4i+3)$
podemos determinar todas as colunas seguintes;
em particular,
a partir da subchave da rodada $i$
podemos construir a subchave da rodada $i+1$.
Se interpretarmos a chave original como a ``subchave da rodada $0$'',
esta relação também vale para $i = 0$;
esta observação simplifica o código.

Especificamente: suponha que a subchave da rodada $i$
seja dada pela matriz
\begin{equation*}
    \left[ \colvec{a_i} \colvec{b_i} \colvec{c_i} \colvec{d_i} \right].
\end{equation*}
Temos $a_i = W(4i)$, $b_i = W(4i+1)$, $c_i = W(4i+2)$ e $d_i = W(4i+3)$.
Basta substituir os valores pelas fórmulas válidas para os $W$
para chegarmos a
\begin{align*}
    a_{i+1} &= a_i \xor T(d_i) \\
    b_{i+1} &= b_i \xor a_{i+1} \\
    c_{i+1} &= d_i \xor b_{i+1} \\
    d_{i+1} &= d_i \xor c_{i+1}
\end{align*}
A transformação $T$ depende apenas do número da rodada atual e do valor de $d_i$;
de posse de $a_{i+1}$, podemos computar $b_{i+1}$,
e então $c_{i+1}$
e, finalmente, $d_{i+1}$.
Portanto, podemos computar a subchave $i+1$ a partir da subchave $i$.

As equações anteriores podem ser reescritas
(passando o segundo termo para o outro lado da equação)
como
\begin{align*}
    d_i &= d_{i+1} \xor c_{i+1} \\
    c_i &= d_{i+1} \xor b_{i+1} \\
    b_i &= b_{i+1} \xor a_{i+1} \\
    a_i &= a_{i+1} \xor T(d_i)
\end{align*}
Isso mostra como calcular a subchave $i$ a partir da subchave $i+1$.
Os três primeiros valores ($d_i$, $c_i$ e $b_i$)
podem ser computados diretamente.
Como já computamos $d_i$, podemos aplicar a transformação $T$
e obter $a_i$.
\footnote{
    Interessante notar que nós computamos $T$ novamente,
    em vez de inverter $T$,
    de maneira semelhante ao que acontecia com o DES.
}
Repetindo este procedimento várias vezes,
podemos calcular a chave original a partir de qualquer subchave.

Estes algoritmos estão implementados no arquivo \verb"aes/subkeys.cpp".

\subsection{Etapas intermediárias do algoritmo}

As etapas \emph{AddRoundKey}, \emph{SubBytes}, \emph{ShiftRow} e \emph{MixColumn}
foram implementadas cada uma numa função separada.
As interfaces estão no arquivo \verb"aes/primitives.h".

\begin{cppcode}
    namespace aes {
        matrix addroundkey( const matrix & data, const matrix & key );
        matrix addroundkey_inv( const matrix & data, const matrix & key );
        matrix subbytes( const matrix & );
        matrix subbytes_inv( const matrix & );
        matrix shiftrow( const matrix & );
        matrix shiftrow_inv( const matrix & );
        matrix mixcolumn( const matrix & );
        matrix mixcolumn_inv( const matrix & );
    }
\end{cppcode}

Cada função \verb"_inv" correspondente é a inversa da função original,
exceto \verb"addroundkey_inv".
A inversa da \emph{AddRoundKey} foi definida
de forma a comutar com \emph{MixColumn}.
Isto é,
\begin{equation}
    IARK( IMC(d), k ) = IMC( ARK(d, k) ),
    \label{iark-imc}
\end{equation}
para o dado $d$ e a chave $k$.
Esta alteração foi feita visando implementar tanto o algoritmo de encriptação
quanto o de decriptação com o mesmo formato.

Para satisfazer a equação anterior, note que
\begin{equation*}
    ARK( d, k ) = d \xor k.
\end{equation*}
Agora, $IMC$ é uma operação linear; portanto,
\begin{equation*}
    IMC( ARK(d, k) ) = IMC( d \xor k ) = IMC(d) \xor IMC(k)
\end{equation*}
Portanto, basta definir
\begin{equation*}
    IARK( d', k ) = d' \xor IMC(k)
\end{equation*}
para que a equação~\ref{iark-imc} seja satisfeita.

\subsection{Os algoritmos de encriptação e decriptação}

A interface para o algoritmo AES está disponível no arquivo \verb"aes/aes.h".
\begin{cppcode}
    namespace aes {
        matrix aes( const matrix & data, const matrix & key, int rounds = 10 );
        matrix aes_inv( const matrix & data, const matrix & key, int rounds = 10 );
    }
\end{cppcode}

Separamos \verb"aes" e \verb"aes_inv" para simplificar a interface.

Conforme discutido em aula, o algoritmo de encriptação e o de decriptação do AES
são, estruturalmente, idênticos;
o único detalhe que deve ser levado em consideração
é que devemos alterar o tipo de operação
--- isto é, usar \verb"mixcolumn_inv" em vez de \verb"mixcolumn".

Pensando nisso,
implementamos uma função genérica \verb"aes_aux",
que é configurável, através de ponteiros para funções,
para ser tanto o \verb"aes" quanto o \verb"aes_inv".

\begin{cppcode}
    matrix aes_aux(
        const matrix & data,
        const std::vector<matrix> & keys,
        int rounds,
        matrix (*ARK)( const matrix &, const matrix & ),
        matrix (*SB)( const matrix & ),
        matrix (*SR)( const matrix & ),
        matrix (*MC)( const matrix & )
    )
    {
        matrix r = aes::addroundkey(data, keys[0]); // $\label{linha1}$
        for( int i = 1; i < rounds; i++ ) {
            r = SB( r );
            r = SR( r );
            r = MC( r );
            r = ARK( r, keys[i] );
        }
        r = SB( r );
        r = SR( r );
        r = aes::addroundkey( r, keys[rounds] ); // $\label{linha2}$

        return r;
    }
\end{cppcode}

As funções \verb"aes" e \verb"aes_inv" essencialmente chamam \verb"aes_aux"
com as operações primitivas adequadas.

Um detalhe que deve ser mencionado é o fato de usarmos, diretamente,
\verb"aes::addroundkey" nas linhas \ref{linha1} e~\ref{linha2}.
A variável \verb"ARK" é usada,
por \verb"aes" e \verb"aes_inv",
para referir-se a \verb"addroundkey" e a \verb"addroundkey_inv",
respectivamente.
Mas \verb"addroundkey_inv" não é o inverso de \verb"addroundkey";
ela foi alterada para satisfazer à equação \ref{iark-imc}.
Isso garante a corretude do laço interno no algoritmo de decriptação.

Mas, como não há o \emph{MixColumn} na última rodada
nem antes da primeira,
o \emph{AddRoundKey} das linhas \ref{linha1} e~\ref{linha2}
precisam ser a função \verb"aes::addroundkey",
mesmo no algoritmo de decriptação.
Por isso, não usamos a variável \verb"ARK" nestas linhas.

Estas funções estão implementadas em \verb"aes/aes.cpp".

\subsection{Geração de integrais}

De posse destas funções,
ficou muito simples implementar o programa \verb"generate_aes_integrals".
O formato de entrada deste programa é uma lista de casos de teste
delimitada por fim de arquivo.
Cada caso de teste é constituido de duas linhas com 16 bytes cada (em hexadecimal),
seguidos de dois números $i$ e $r$ em decimal.

A primeira linha é uma linha de dados,
a segunda linha é a chave,
$i$ é o índice que deve ser saturado e $r$ é o número de rodadas.

Para cada caso de teste,
o programa irá gerar uma integral, com o índice $i$ saturado,
e as constantes para as demais posições vem da linha de dados.
O programa, então, submete os textos da integral a $r$ rodadas do AES,
e as imprime.

Cada bloco de 256 textos está separado por uma linha em branco.

Exemplo de entrada:
\footnote{
    Em ambos os casos de teste, a chave é a codificação UTF-8 do texto
    \texttt{CS \textbackslash{}subset MATH}.
    Os primeiros 15 caracteres do primeiro caso é a codificação UTF-8
    de \texttt{Criptoanálise}
    e o texto do segundo caso de teste é a codificação UTF-8
    de \texttt{Encrypt/Decrypt}.
}
\begin{minted}[gobble=4]{text}
    72 43 70 69 6F 74 6E 61 A1 C3 69 6C 65 73 0A 00
    53 43 5C 20 75 73 73 62 74 65 4D 20 54 41 0A 48
    15
    4

    6E 45 72 63 70 79 2F 74 65 44 72 63 70 79 0A 74
    53 43 5C 20 75 73 73 62 74 65 4D 20 54 41 0A 48
    6
    4
\end{minted}
Esta entrada foi usada para gerar as integrais do arquivo
\verb"sample_integrals.txt".

\end{document}
