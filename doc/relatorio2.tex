\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}

\usepackage{tikz}

\usepackage{minted}
\newminted{cpp}{gobble=4}
\newcommand{\xor}{\oplus}

\newcommand{\colvec}[1]{
    \tikz[baseline=-3pt]{
        \node (center) at (0, 0) {$#1$};
        \draw (center) -- (0, 1) (0, 1.2);
        \draw (center) -- (0, -1) (0, -1.2);
    }
    % O -3pt, o 1.2 e o -1.2 são admitidamente gambiarrizados.
}

\title{
    INE5451 - Tópicos Especiais em Algoritmos I \\
    Introdução à Criptoanálise \\
    Relatorio II
}
\author{
    Lucas Zarbato - 11100890\\
    Tiago Royer - 12100776
}

\date{3 de Julho de 2015}

\begin{document}

\maketitle

\section{Introdução}

O trabalho a ser entregue consistia de seis questões
relacionadas ao conteúdo aprendido em aula.
As três primeiras eram obrigatórias
e envolviam a implementação do ataque integral ao AES,
implementação do RSA
e o desenvolvimento de um ataque linear a uma SPN.
As últimas três eram eletivas e precisavam ser escolhidas
dentre um leque de 6 opções.
Escolhemos fazer as últimas três questões, relacionadas ao log discreto.

Novamente, fizemos todos os programas em C++.
Nosso código está disponível em \texttt{https://github.com/royertiago/INE5451}.

\section{Questão 2 --- Ataque quadrado ao AES}

Este problema pedia que implementássemos o ataque quadrado ao AES.
Como o algoritmo foi estudado em detalhes na aula,
discutiremos aqui apenas questões de implementação.

\subsection{Estruturas de dados}

Definimos duas estruturas de dados para este algoritmo.
A primeira,
a classe \verb"polynomial"
(definida no arquivo \verb"aes/polynomial.h"),
encapsula toda a parafernália relacionada
à manipulação de elementos no corpo de Galois usado pelo AES.
A multiplicação de dois elementos é tabelada no início do programa,
reduzindo o cálculo do produto de dois elementos do corpo
a um acesso a vetor.

A segunda clase,
\verb"matrix" (definida em \verb"aes/matrix.h"),
representa as chaves, subchaves, dados a serem cifrados
e algumas operações lineares.

\subsection{Reconstrução de subchaves}

Embora a norma do AES defina a geração de subchaves em termos de
uma lista de vetores-coluna%
\footnote{
    Usamos o termo ``vetor-coluna'' no sentido que ele tem na álgebra linear.
    Adicionamos o sufixo ``-coluna'' para diferenciá-lo
    do conceito de ``vetor'' utilizado nas linguagens de programação
    (o ``vetor'' de ``vetor de subchaves'').
},
usando apenas as colunas $W(4i)$, $W(4i+1)$, $W(4i+2)$ e $W(4i+3)$
podemos determinar todas as colunas seguintes;
em particular,
a partir da subchave da rodada $i$
podemos construir a subchave da rodada $i+1$.
Se interpretarmos a chave original como a ``subchave da rodada $0$'',
esta relação também vale para $i = 0$;
esta observação simplifica o código.

Especificamente: suponha que a subchave da rodada $i$
seja dada pela matriz
\begin{equation*}
    \left[ \colvec{a_i} \colvec{b_i} \colvec{c_i} \colvec{d_i} \right].
\end{equation*}
Temos $a_i = W(4i)$, $b_i = W(4i+1)$, $c_i = W(4i+2)$ e $d_i = W(4i+3)$.
Basta substituir os valores pelas fórmulas válidas para os $W$
para chegarmos a
\begin{align*}
    a_{i+1} &= a_i \xor T(d_i) \\
    b_{i+1} &= b_i \xor a_{i+1} \\
    c_{i+1} &= d_i \xor b_{i+1} \\
    d_{i+1} &= d_i \xor c_{i+1}
\end{align*}
A transformação $T$ depende apenas do número da rodada atual e do valor de $d_i$;
de posse de $a_{i+1}$, podemos computar $b_{i+1}$,
e então $c_{i+1}$
e, finalmente, $d_{i+1}$.
Portanto, podemos computar a subchave $i+1$ a partir da subchave $i$.

As equações anteriores podem ser reescritas
(passando o segundo termo para o outro lado da equação)
como
\begin{align*}
    d_i &= d_{i+1} \xor c_{i+1} \\
    c_i &= d_{i+1} \xor b_{i+1} \\
    b_i &= b_{i+1} \xor a_{i+1} \\
    a_i &= a_{i+1} \xor T(d_i)
\end{align*}
Isso mostra como calcular a subchave $i$ a partir da subchave $i+1$.
Os três primeiros valores ($d_i$, $c_i$ e $b_i$)
podem ser computados diretamente.
Como já computamos $d_i$, podemos aplicar a transformação $T$
e obter $a_i$.
\footnote{
    Interessante notar que nós computamos $T$ novamente,
    em vez de inverter $T$,
    de maneira semelhante ao que acontecia com o DES.
}
Repetindo este procedimento várias vezes,
podemos calcular a chave original a partir de qualquer subchave.

A interface para o algoritmo de reconstrução de chaves fica, simplesmente,
\begin{cppcode}
    matrix superkey( const matrix & subkey, int round );
\end{cppcode}
Esta função está implementada em \verb"aes/subkeys.cpp".

\subsection{Geração de integrais}

Para gerar as duas integrais, construimos o programa \verb"generate_aes_integrals.cpp".
Para a primeira integral, escolhemos como base o texto em claro
\verb"AESCryptanalysis"
(isto é, a codificação em UTF-8 de \verb"AESCryptanalysis"),
e saturamos o byte de índice 12;
para a segunda integral, escolhemos o texto \verb"Maths&Algorithms"
e saturamos o byte de índice 7.
A chave para ambas as é \verb"CS\subseteq MATH".
\footnote{
    Os bytes saturados foram escolhidos através de tentativa-e-erro
    de modo a dificultar o ataque quadrado.
    Especificamente,
    com estas integrais,
    o ataque não determina unicamente a chave original:
    existem dois candidados a subchave da 4ª rodada,
    diferindo apenas no byte de índice 6.
}

O arquivo de entrada fornecido ao programa está disponível em
\verb"doc/integrals.in";
a saída resultante está disponível em \verb"doc/integrals.out".

\subsection{Implementação do ataque}

De acordo com o que foi discutido em aula,
a integral chega na última rodada com todas as posições balanceadas,
mas não necessariamente saturadas.
\begin{equation*}
    \text{Elemento}_i =
    \begin{bmatrix}
        a^i_{00} & a^i_{01} & a^i_{02} & a^i_{03} \\
        a^i_{10} & a^i_{11} & a^i_{12} & a^i_{13} \\
        a^i_{20} & a^i_{21} & a^i_{22} & a^i_{23} \\
        a^i_{30} & a^i_{31} & a^i_{32} & a^i_{33} \\
    \end{bmatrix}
\end{equation*}
A última rodada contém as operações \emph{SubBytes},
\emph{ShiftRow} e \emph{AddRoundKey}.
Conforme observado em aula, \emph{SubBytes} e \emph{ShiftRow} comutam;
portanto, podemos considerar que a última rodada é
\begin{equation*}
    SR \to SB \to ARK.
\end{equation*}
Como $SR$ apenas altera a posição das entradas da matriz,
o balanceamento de todas as posições da integral é preservado
após passarmos-na por $SR$.
Portanto, efetivamente,
podemos nos preocupar apenas com as operações
\begin{equation*}
    SB \to ARK.
\end{equation*}
Como ambas as operações trabalham byte-a-byte,
podemos fazer força-bruta em cada byte da 4ª subchave separadamente,
em vez de atacar todos os 128 bits de uma vez só.

Se um certo byte $k$ for, de fato,
o byte da subchave na posição $ij$,
então
\begin{equation}
    \label{balanceamento}
    \bigoplus_{0 \leq t \leq 255} \verb"s_box_inv["k \xor a^t_{ij}\verb"]" = 0,
\end{equation}
em que \verb"s_box_inv" é o inverso da caixa-S.
Se $k$ não for o byte certo, ainda pode ser que a equação valha.
Como o valor do $\xor$atório é mais ou menos aleatório,
podemos esperar que um byte errado passe no teste
com probabilidade $2^{-8}$.
Faremos esta hipótese
(de que o $\xor$atório é aleatório para um byte errado)
no restante do texto.

O código está disponível no arquivo \verb"unaes4.cpp".
Ele começa com
\begin{cppcode}
    aes::matrix integral[256];
    int votes[4][4][256] = {0};
    int processed_integrals;
\end{cppcode}

\verb"integral" é a lista dos textos cifrados que pertencem à integral.
\verb"votes[i][j][k]" é a quantidade de integrais
em que o byte $k$ satisfez a equação~\ref{balanceamento}
para a posição $ij$.

Para cada integral que o \verb"main" lê,
a função \verb"process_integrals" é chamada uma vez.
Esta função popula o vetor \verb"votes";
em essência, para cada posição $ij$ e cada byte $k$,
a função testa se a equação~\ref{balanceamento} é válida para a integral atual.
\begin{cppcode}
    void process_integral() {
        for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
        for( int k = 0; k < 256; k++ ) { // [k]ey candidate
            unsigned sum = 0;
            for( int t = 0; t < 256; t++ )
                sum = sum ^ aes::s_box_inv[integral[t][i][j].data ^ k];
            votes[i][j][k] += (sum == 0);
        }
        processed_integrals++;
    }
\end{cppcode}
\verb"integral[t][i][j].data" é a representação,
em \verb"unsigned char",
do byte $a^t_{ij}$.

Após processarmos todas as integrais,
se $k$ é o verdadeiro bit de chave,
então
\begin{equation}
    \label{votos-suficientes}
    \verb"votes[i][j][k] == processed_integrals".
\end{equation}
Com duas integrais,
a probabilidade de um byte errado satisfazer esta equação
é $2^{-16}$.
Cada um dos 255 outros bytes representa uma ``tentativa''
de satisfazer à equação sem ser o byte certo;
portanto,
a chance de um byte específico não ser unicamente determinado
após duas integrais é
\begin{equation*}
    1 - (1 - 2^{-16})^{255} \approx 0.00388
\end{equation*}
Como são $16$ posições possíveis na matriz,
existem, de fato, $16*255$ diferentes oportunidades
para que a equação~\ref{balanceamento} seja satisfeita com o byte errado.
Portanto,
a chance de que algum dos bytes tenha duas respostas
(uma vindo do byte certo e outra conseguida ao acaso)
é de
\begin{equation*}
    1 - (1 - 2^{-16})^{16*255} \approx 0.06036 \approx 6\%,
\end{equation*}
que é uma probabilidade consideravelmente alta
--- não é nada ``esmagadora'', ao contrário do que o Barreto diz%
\footnote{
    Concluímos que ou o está errado o Barreto
    ou está errada nossa hipótese de que
    um byte aleatório tem chance $2^{-8}$ de passar no teste.
    Sinceramente, eu (Tiago Royer) confio mais no Barreto...
}.
De fato, os exemplos que usamos deixam escapar um byte.

Para garantir corretude do algoritmo,
precisamos, então, testar todas as combinações possíveis de chave geradas.
Isto é tarefa da função \verb"process_votes".
O começo desta função é%
\footnote{
    O código desta função está um pouco diferente no arquivo \texttt{unaes4.cpp}
    pois lá levamos em conta algum tratamento de erros,
    para propósitos de depuração.
}
\begin{cppcode}
    void process_votes() {
        std::vector<aes::polynomial> voted[4][4];
        int brute_force_key_space = 1;
\end{cppcode}
\verb"voted[i][j]" conterá uma lista de todos os bytes $k$
que passaram em todos os teste na posição $ij$;
isto é, os que satisfizerem a equação~\ref{votos-suficientes}.
\verb"brute_force_key_space" é apenas por curiosidade:
esta variável guardará a quantidade de combinações possíveis para a 4ª subchave.

A etapa seguinte é popular os vetores \verb"voted[i][j]".
\begin{cppcode}
        for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ ) {
            for( int k = 0; k < 256; k++ )
                if( votes[i][j][k] == processed_integrals )
                    voted[i][j].push_back( aes::polynomial(k) );

            brute_force_key_space *= voted[i][j].size();
        }
\end{cppcode}
Este trecho de código evidencia que o espaço de chaves
cresce exponencialmente a cada byte não unicamente determinado.

O restante do código não é muito interessante;
ele apenas gera e testa todas as possíveis subchaves,
baseado na matriz \verb"voted" gerada anteriormente.

Como em nosso formato de entrada nós não disponibilizamos o texto claro,
precisamos de um pequeno ``malabarismo'' para testar se uma subchave está certa:
nós executam o algoritmo de decriptação do AES
em dois elementos diferentes da integral.
Caso o resultado difira em, exatamente, uma posição,
consideramos aquela chave válida.

Para cada byte da chave,
existem $255$ ``tentativas'' de passar um valor errado no teste.
Podemos interpretar isso como $255$ ensaios de Bernoulli,
com probabilidade de sucesso de $2^{-8}$ cada.
A quantidade esperada de ``sucessos'' em passar um valor errado
é $255*2^{-8}$;
portanto, podemos esperar $1 + 255/256$
diferentes candidatos para cada byte da chave.

A quantidade de possíveis subchaves
é o produto das quantidades de candidatos a bytes da subchave;
como existem $16$ bytes independentes,
a quantidade de candidatos subchaves que são filtrados com uma única integral é
\begin{equation*}
    \left(1 + \frac{255}{256}\right) ^{16} \approx 63517.728 \approx 2^{16}.
\end{equation*}
Portanto, precisamos executar,
em média, $2^{16}$ decifragens para encontrar a chave certa
usando apenas uma integral.

A título de curiosidade, usar apenas a segunda integral gerada
exige busca sobre $12\,288$ chaves,
enquanto que usar apenas a primeira exige $248\,832$ tentativas.


\section{Questão 3 --- RSA}

Como os dois principais algoritmos
(quadrado-e-multiplica e Euclides extendido)
são simples de implementar
(e o pseudo-código para eles está disponível nas notas de aula),
não há muito o que discutir neste exercício.

Esta questão consistia em quebrar o RSA
a partir da chave pública.
Como a chave era admitidamente pequena ($n = 18923$),
nos sentimos autorizados a fatorar o $n$ usando o comando \verb"factor" do UNIX.
Obtemos assim $p = 127$ e $q = 149$.

Nossa implementação do RSA (disponível no arquivo \verb"rsa/rsa.hpp")
faz o resto de posse de $p$, $q$ e $b$.
Computamos $\phi(n) = 18648$ e $a = 5797$;
e o decodificador está implementado em \verb"micro_rsa.cpp".
O shell script \verb"micro_rsa_run.sh"
executa o decodificador com os parâmetros $p$, $q$ e $b$,
e imprime o texto em claro correspondente.

\section{Questões eletivas}

Escolhemos as questões sobre logaritmo discreto
pois eram as únicas que exigiam implementação.

\subsection{Questão 7 --- Algoritmo de Shanks}

Esta questão exigia a implementação do algoritmo de Shanks para calcular o log discreto.
A implementação está disponível no arquivo \verb"shanks.cpp".
Fizemos no formato de uma questão da Maratona de programação;
o programa lê diversos casos de teste (delimitado por fim de arquivo)
contendo $a$, $b$ e $n$,
e imprime, para cada caso de teste, $\log_a b (\mod n)$.

Como teste, nos foi pedido para calcular $\log_6 248388\ (\mathrm{mod}\ 458009) = 232836$.

\subsection{Questão 8 --- Algoritmo de Pohlig-Hellman}

Novamente seguimos o formato da Maratona.
A implementação está em \verb"pohlig_hellman.cpp".

Além do RSA, este era o único exercício que exigia fatoração de números;
por isso, nos implementamos um algoritmo de fatoração bastante simplificado:
ele apenas testa todos os primos até $223$ e desiste se não consegue continuar.
(A fatoração está implementada em \verb"math/factor.cpp")

Como teste, nos foi pedido para calcular $\log_{10} 12611\ (\mathrm{mod}\ 31153) = 17102$.

\end{document}
