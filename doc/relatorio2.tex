\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}

\usepackage{tikz}

\usepackage{minted}
\newminted{cpp}{gobble=4, linenos, mathescape}
\newcommand{\xor}{\otimes}

\newcommand{\colvec}[1]{
    \tikz[baseline=-3pt]{
        \node (center) at (0, 0) {$#1$};
        \draw (center) -- (0, 1) (0, 1.2);
        \draw (center) -- (0, -1) (0, -1.2);
    }
    % O -3pt, o 1.2 e o -1.2 são admitidamente gambiarrizados.
}

\title{
    INE5451 - Tópicos Especiais em Algoritmos I \\
    Introdução à Criptoanálise \\
    Relatorio II
}
\author{
    Lucas Zarbato - 11100890\\
    Tiago Royer - 12100776
}

\date{3 de Julho de 2015}

\begin{document}

\maketitle

\section{Introdução}

O trabalho a ser entregue consistia de seis questões
relacionadas ao conteúdo aprendido em aula.
As três primeiras eram obrigatórias
e envolviam a implementação do ataque integral ao AES,
implementação do RSA
e o desenvolvimento de um ataque linear a uma SPN.
As últimas três eram eletivas e precisavam ser escolhidas
dentre um leque de 6 opções.
Escolhemos fazer as últimas três questões, relacionadas ao log discreto.

Novamente, fizemos todos os programas em C++.
Nosso código está disponível em \texttt{https://github.com/royertiago/INE5451}.

\section{Questão 2 --- Ataque quadrado ao AES}

Este problema pedia que implementássemos o ataque quadrado ao AES.
Como o algoritmo foi estudado em detalhes na aula,
discutiremos aqui apenas questões de implementação.

\subsection{Estruturas de dados}

Definimos duas estruturas de dados para este algoritmo.
A primeira,
a classe \verb"polynomial"
(definida no arquivo \verb"aes/polynomial.h"),
encapsula toda a parafernália relacionada
à manipulação de elementos no corpo de Galois usado pelo AES.
A multiplicação de dois elementos é tabelada no início do programa,
reduzindo o cálculo do produto de dois elementos do corpo
a um acesso a vetor.

A segunda clase,
\verb"matrix" (definida em \verb"aes/matrix.h"),
representa as chaves, subchaves, dados a serem cifrados
e algumas operações lineares.

\subsection{Reconstrução de subchaves}

Embora a norma do AES defina a geração de subchaves em termos de
uma lista de vetores-coluna%
\footnote{
    Usamos o termo ``vetor-coluna'' no sentido que ele tem na álgebra linear.
    Adicionamos o sufixo ``-coluna'' para diferenciá-lo
    do conceito de ``vetor'' utilizado nas linguagens de programação
    (o ``vetor'' de ``vetor de subchaves'').
},
usando apenas as colunas $W(4i)$, $W(4i+1)$, $W(4i+2)$ e $W(4i+3)$
podemos determinar todas as colunas seguintes;
em particular,
a partir da subchave da rodada $i$
podemos construir a subchave da rodada $i+1$.
Se interpretarmos a chave original como a ``subchave da rodada $0$'',
esta relação também vale para $i = 0$;
esta observação simplifica o código.

Especificamente: suponha que a subchave da rodada $i$
seja dada pela matriz
\begin{equation*}
    \left[ \colvec{a_i} \colvec{b_i} \colvec{c_i} \colvec{d_i} \right].
\end{equation*}
Temos $a_i = W(4i)$, $b_i = W(4i+1)$, $c_i = W(4i+2)$ e $d_i = W(4i+3)$.
Basta substituir os valores pelas fórmulas válidas para os $W$
para chegarmos a
\begin{align*}
    a_{i+1} &= a_i \xor T(d_i) \\
    b_{i+1} &= b_i \xor a_{i+1} \\
    c_{i+1} &= d_i \xor b_{i+1} \\
    d_{i+1} &= d_i \xor c_{i+1}
\end{align*}
A transformação $T$ depende apenas do número da rodada atual e do valor de $d_i$;
de posse de $a_{i+1}$, podemos computar $b_{i+1}$,
e então $c_{i+1}$
e, finalmente, $d_{i+1}$.
Portanto, podemos computar a subchave $i+1$ a partir da subchave $i$.

As equações anteriores podem ser reescritas
(passando o segundo termo para o outro lado da equação)
como
\begin{align*}
    d_i &= d_{i+1} \xor c_{i+1} \\
    c_i &= d_{i+1} \xor b_{i+1} \\
    b_i &= b_{i+1} \xor a_{i+1} \\
    a_i &= a_{i+1} \xor T(d_i)
\end{align*}
Isso mostra como calcular a subchave $i$ a partir da subchave $i+1$.
Os três primeiros valores ($d_i$, $c_i$ e $b_i$)
podem ser computados diretamente.
Como já computamos $d_i$, podemos aplicar a transformação $T$
e obter $a_i$.
\footnote{
    Interessante notar que nós computamos $T$ novamente,
    em vez de inverter $T$,
    de maneira semelhante ao que acontecia com o DES.
}
Repetindo este procedimento várias vezes,
podemos calcular a chave original a partir de qualquer subchave.

A interface para o algoritmo de reconstrução de chaves fica, simplesmente,
\begin{cppcode}
    matrix superkey( const matrix & subkey, int round );
\end{cppcode}
Esta função está implementada em \verb"aes/subkeys.cpp".

\subsection{Geração de integrais}

Implementamos o algoritmo AES por completo, incluindo encriptação e decriptação.
No arquivo \verb"aes/aes.h", disponibilizamos uma interface para o algoritmo;
em essência, é
\begin{cppcode}
    matrix aes( const matrix & data, const matrix & key, int rounds = 10 );
    matrix aes_inv( const matrix & data, const matrix & key, int rounds = 10 );
\end{cppcode}
(O código destas funções está implementado em \verb"aes/aes.cpp".)

De posse destas funções,
ficou muito simples implementar o programa \verb"generate_aes_integrals".
O formato de entrada deste programa é uma lista de casos de teste
delimitada por fim de arquivo.
Cada caso de teste é constituido de duas linhas com 16 bytes cada (em hexadecimal),
seguidos de dois números $i$ e $r$ em decimal.

A primeira linha é uma linha de dados,
a segunda linha é a chave,
$i$ é o índice que deve ser saturado e $r$ é o número de rodadas.

Para cada caso de teste,
o programa irá gerar uma integral, com o índice $i$ saturado,
e as constantes para as demais posições vem da linha de dados.
O programa, então, submete os textos da integral a $r$ rodadas do AES,
e as imprime.

Cada bloco de 256 textos está separado por uma linha em branco.

Exemplo de entrada:
\footnote{
    Em ambos os casos de teste, a chave é a codificação UTF-8 do texto
    \texttt{CS \textbackslash{}subset MATH}.
    Os primeiros 15 caracteres do primeiro caso é a codificação UTF-8
    de \texttt{Criptoanálise}
    e o texto do segundo caso de teste é a codificação UTF-8
    de \texttt{Encrypt/Decrypt}.
}
\begin{minted}[gobble=4]{text}
    72 43 70 69 6F 74 6E 61 A1 C3 69 6C 65 73 0A 00
    53 43 5C 20 75 73 73 62 74 65 4D 20 54 41 0A 48
    15
    4

    6E 45 72 63 70 79 2F 74 65 44 72 63 70 79 0A 74
    53 43 5C 20 75 73 73 62 74 65 4D 20 54 41 0A 48
    6
    4
\end{minted}
Esta entrada foi usada para gerar as integrais do arquivo
\verb"sample_integrals.txt".

\end{document}
